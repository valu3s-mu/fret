--First Time Point
node FTP() returns (X:bool);
let
  X = true -> false;
tel

--Historically
node H(X:bool) returns (Y:bool);
let
    Y = X -> (X and (pre Y));
tel

--Y since inclusive X
node SI(X,Y: bool) returns (Z:bool);
let
Z = Y and (X or (false -> pre Z));
tel

--Y since X
node S(X,Y: bool) returns (Z:bool);
let
Z = X or (Y and (false -> pre Z));
tel

--Once
node O(X:bool) returns (Y:bool);
let
 Y = X or (false -> pre Y);
tel

node First( X : bool ) returns ( Y : bool );
let
  Y = X -> pre Y;
tel

--Timed Once: less than or equal to N
node OTlore( N: int; X: bool) returns (Y: bool);
    var C:int;
let
    C = if X then 0
        else (-1 -> pre C + (if pre C <0 then 0 else 1));

    Y = First(X)
        ->
        (if C < 0  then false
         else C <= N
        );
tel

-- Timed Historically: less than or equal to N
node HTlore( N: int; X: bool) returns (Y: bool);
let
  Y = not OTlore(N, not X);
tel

-- Timed Since: less than or equal to N
node STlore( N: int; X: bool; Y: bool)  returns (Z: bool);
let
  Z = S(X, Y) and OTlore(N, X);
tel

-- Timed Since Inclusive: less than or equal to N
node SITlore( N: int; X: bool; Y: bool)  returns (Z: bool);
let
  Z = SI(X,Y) and OTlore(N, X);
tel


node delay(X:bool;  R:int) returns(Y:bool);
let

  Y = X;
 
tel



node FSM_SensorSpec( MODE:bool; limits:bool; request:bool; senstate:real; SENSTATE:real   ) returns ( );

var pre_senstate:real; sen_fault_state:real; sen_nominal_state:real; sen_transition_state:real; FSM011v1:bool; FSM012:bool; FSM010:bool; FSM013:bool; FTP: bool; 
let


FTP = true->false;


pre_senstate = 0.0 -> pre senstate;
sen_fault_state = 2.0;
sen_nominal_state = 0.0;
sen_transition_state = 1.0;

assert senstate = 0.0 or senstate = 1.0 or senstate = 2.0;
assert SENSTATE = 0.0 or SENSTATE = 1.0 or SENSTATE = 2.0;


 
(* Req text: FSM_Sensor shall always  satisfy (senstate = sen_nominal_state & !request) => SENSTATE = sen_transition_state  *)
FSM011v1 = (H((( senstate = sen_nominal_state and not request ) => SENSTATE = sen_transition_state)));  
 
(* Req text: FSM_Sensor shall  always  satisfy (pre_senstate = sen_fault_state & !request & !  limits) => SENSTATE = sen_transition_state  *)
FSM012 = (H((( pre_senstate = sen_fault_state and not request and not limits ) => SENSTATE = sen_transition_state)));  
 
(* Req text: FSM_Sensor shall always satisfy (senstate = sen_nominal_state & limits)=> SENSTATE = sen_fault_state  *)
FSM010 = (H((( senstate = sen_nominal_state and limits ) => SENSTATE = sen_fault_state)));  
 
(* Req text: FSM_Sensor shall always satisfy (senstate = sen_transition_state & request & MODE) => SENSTATE = sen_nominal_state  *)
FSM013 = (H((( senstate = sen_transition_state and request and MODE ) => SENSTATE = sen_nominal_state)));  

 
 --%PROPERTY FSM011v1;  
 --%PROPERTY FSM012;  
 --%PROPERTY FSM010;  
 --%PROPERTY FSM013; 
--%REALIZABLE MODE, limits, request, senstate;  

tel

