--Historically
node H(X:bool) returns (Y:bool);
let
    Y = X -> (X and (pre Y));
tel

--Y since inclusive X
node SI(X,Y: bool) returns (Z:bool);
let
Z = Y and (X or (false -> pre Z));
tel

--Y since X
node S(X,Y: bool) returns (Z:bool);
let
Z = X or (Y and (false -> pre Z));
tel

--Once
node O(X:bool) returns (Y:bool);
let
 Y = X or (false -> pre Y);
tel

--Timed Once: less than or equal to N
node OTlore( N: int; X: bool) returns (Y: bool);
    var C:int;
let
    C = if X then 0
        else (-1 -> pre C + (if pre C <0 then 0 else 1));

    Y = 0 <= C and C <= N;
tel

--Timed Once: general case
node OT( L: int;  R: int; X: bool) returns (Y: bool);
var  D:bool;
let
  D=delay(X, R);
  Y=OTlore(L-R, D);
tel

-- Timed Historically: general case
node HT( L: int;  R: int; X: bool) returns (Y: bool);
let
  Y = not OT(L, R, not X);
tel

-- Timed Since: general case
node ST( L: int;  R: int; X: bool; Y: bool)  returns (Z: bool);
let
  Z = S(X, Y) and OT(L, R, X);
tel

-- Timed Since: general case
node SIT( L: int;  R: int; X: bool; Y: bool) returns (Z: bool);
let
  Z = SI(X, Y) and OT(L, R, X);
tel


node delay(X:bool;  R:int) returns(Y:bool);
let

  Y = X;
 
tel



node FSM_AutopilotSpec( apfail:bool; good:bool; standby:bool; state:real; supported:bool; STATE:real   ) returns ( );

var ap_maneuver_state:real; ap_nominal_state:real; ap_standby_state:real; ap_transition_state:real; FSM003v2:bool; FSM002:bool; FSM003:bool; FSM008v1:bool; FSM009:bool; FSM005:bool; FSM008v2:bool; FSM007:bool; FSM004v2:bool; FSM006:bool; FSM004:bool; FTP: bool; 
let


FTP = true->false;


ap_maneuver_state = 2.0;
ap_nominal_state = 1.0;
ap_standby_state = 3.0;
ap_transition_state = 0.0;




 
(* Req text: FSM_Autopilot shall always satisfy state = ap_transition_state & good & supported & ! standby => STATE = ap_nominal_state  *)
FSM003v2 = (H((state = ap_transition_state and good and supported and not standby => STATE = ap_nominal_state)));  
 
(* Req text: FSM_Autopilot shall always satisfy (standby & state = ap_transition_state)=> STATE = ap_standby_state  *)
FSM002 = true;--(H((( standby and state = ap_transition_state ) => STATE = ap_standby_state)));  
 
(* Req text: FSM_Autopilot shall always satisfy state = ap_transition_state & good & supported => STATE = ap_nominal_state  *)
FSM003 = (H((state = ap_transition_state and good and supported => STATE = ap_nominal_state)));  
 
(* Req text:  FSM_Autopilot shall always satisfy (state = ap_standby_state & !standby) => STATE = ap_transition_state  *)
FSM008v1 = true; 
 
(* Req text: FSM_Autopilot shall always satisfy (state = ap_standby_state & apfail )=> STATE = ap_maneuver_state  *)
FSM009 = (H((( state = ap_standby_state and apfail ) => STATE = ap_maneuver_state)));  
 
(* Req text: FSM_Autopilot shall always satisfy (state = ap_nominal_state & standby) => STATE = ap_standby_state  *)
FSM005 = (H((( state = ap_nominal_state and standby ) => STATE = ap_standby_state)));  
 
(* Req text: FSM_Autopilot shall always satisfy (state = ap_standby_state & ! standby & ! apfail ) => STATE = ap_transition_state  *)
FSM008v2 = (H((( state = ap_standby_state and not standby and not apfail ) => STATE = ap_transition_state)));  
 
(* Req text: FSM_Autopilot shall always satisfy (state = ap_maneuver_state & supported & good) => STATE = ap_transition_state  *)
FSM007 = true; 
 
(* Req text: FSM_Autopilot shall always satisfy state = ap_nominal_state & ! good & ! standby => STATE = ap_maneuver_state  *)
FSM004v2 = (H((state = ap_nominal_state and not good and not standby => STATE = ap_maneuver_state)));  
 
(* Req text: FSM_Autopilot shall always satisfy (state = ap_maneuver_state & standby & good) => STATE = ap_standby_state  *)
FSM006 = true; 
 
(* Req text: FSM_Autopilot shall always satisfy (!good & state = ap_nominal_state) => STATE=ap_maneuver_state  *)
FSM004 = true;--(H((( not good and state = ap_nominal_state ) => STATE = ap_maneuver_state)));  

assert state=0.0 or state=1.0 or state=2.0 or state=3.0;
assert STATE=0.0 or STATE=1.0 or STATE=2.0 or STATE=3.0;


 
 --%PROPERTY FSM003v2;  
 --%PROPERTY FSM002;  
 --%PROPERTY FSM003;  
 --%PROPERTY FSM008v1;  
 --%PROPERTY FSM009;  
 --%PROPERTY FSM005;  
 --%PROPERTY FSM008v2;  
 --%PROPERTY FSM007;  
 --%PROPERTY FSM004v2;  
 --%PROPERTY FSM006;  
 --%PROPERTY FSM004; 
--%REALIZABLE apfail, good, standby, state, supported;  

tel

